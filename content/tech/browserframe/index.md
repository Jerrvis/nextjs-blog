---
title: 浏览器每一帧都会做些什么(事件循环)
date: 2023-3-20 14:50:43
description: 浏览器的事件循环机制
tags:
  - interview
  - browser
---



## 浏览器帧

一般的浏览器刷新率跟屏幕差不多60hz，平均下来是16.6ms(1000s / 60hz) 一帧。

在这期间浏览器主要会去完成回调函数与页面渲染这两个工作。

![brower_frame](https://aerotwist.com/static/blog/the-anatomy-of-a-frame/anatomy-of-a-frame.svg)



## Frame Start

Frame Start 阶段是浏览器渲染引擎在每一帧开始时执行的第一个阶段，也称为开始阶段或更新阶段。

在 Frame Start 阶段，浏览器会执行以下主要任务：

1. 收集用户输入事件：浏览器会检查是否有新的用户输入事件需要处理，如**鼠标点击、键盘输入**等。
2. 检查布局信息：浏览器会检查是否有元素的布局信息需要更新，如元素的位置、大小等。
3. 准备渲染：浏览器会准备好当前帧需要绘制的元素，并计算它们的层级、透明度等信息，为下一步的绘制做好准备。
4. 检查样式变化：浏览器会检查是否有元素的样式信息需要更新，如颜色、字体、边框等。
5. 更新文本信息：浏览器会检查是否有文本内容需要更新，如用户输入、动态生成的内容等。

在 Frame Start 阶段，浏览器会执行一些优化策略，以尽可能提高性能和响应速度。例如，浏览器可能会对一些不必要的布局和样式信息更新进行缓存，避免重复计算，从而提高性能。同时，浏览器也会根据当前帧的需求和硬件环境等因素来调整执行优先级，以保证流畅的动画效果和用户体验。



##  Input Event Handlers

在渲染引擎的渲染流程中，Frame Start 阶段之后的下一个阶段是 Input Event Handlers 阶段。在该阶段，浏览器会执行 JavaScript 代码来响应用户输入事件，如点击、滚动、键盘输入等。JavaScript 代码可能会修改文档树或样式信息，从而触发后续的布局和绘制操作。

在 Input Event Handlers 阶段，浏览器会执行以下主要任务：

1. **处理用户输入事件**：浏览器会执行 JavaScript 代码来处理用户输入事件，如点击、滚动、键盘输入等。
2. 更新文档树和样式信息：JavaScript 代码可能会修改**文档树**或**样式信息**，从而触发后续的布局和绘制操作。
3. 响应用户操作：JavaScript 代码可能会执行一些操作，如发送网络请求、更新本地存储等。

这个阶段也是js的事件循环的一部分，js会按照事件循环，完成一个宏任务，及该宏任务里的同步队列中所有的微任务。

由于 Input Event Handlers 阶段的执行时间可能会很长，可能会对性能和响应速度产生影响。因此，编写高效的 JavaScript 代码以减少执行时间，避免阻塞其他阶段的执行，是很重要的。



## Request Animation Frame

在 Event Handler 阶段之后是 Request Animation Frame (RAF) 阶段。RAF 是一种浏览器提供的 API，它允许 JavaScript 在下一次浏览器绘制之前执行指定的动画或动作，以便在页面中实现流畅的动画效果。

在 RAF 阶段，浏览器会执行以下主要任务：

1. 执行 Request Animation Frame 回调函数：如果 JavaScript 代码通过 RAF API 注册了回调函数，则浏览器会在此阶段执行该回调函数，以便在屏幕每一帧更新时更新动画状态。
2. 更新动画状态：动画帧回调函数通常会修改元素的位置、大小、透明度等属性，从而触发后续的布局和绘制操作。

由于 RAF 阶段的执行时间通常很短，因此它不太可能对性能和响应速度产生显著影响。然而，由于 `requestAnimationFrame()` 方法在每一帧都会执行动画帧回调函数，因此如果动画帧回调函数执行的任务过于繁重，可能会导致帧率下降，从而影响动画的流畅度。



如下为一段代码，点击按钮，浏览器执行如下。

``` html
<body>
  <button id="test">按钮</button>
  <script>
      let btn = document.getElementById('test')

      let frameCount = 0

      btn.addEventListener('click', () => {
        console.log('任务开始')

        setTimeout(() => {
          console.log('宏任务 5')
          Promise.resolve().then(() => console.log('微任务 7'))
          console.log('同步任务 6')
            
          requestAnimationFrame(() => {
            console.log('帧结束 ' + frameCount)
            frameCount += 1
          })
        })

        let a = new Promise((resolve, reject) => {
          console.log('同步任务 1')
          resolve()
        })
          .then(() => {
            console.log('微任务 3')
          })
          .then(() => {
            console.log('微任务 4')
          })

        console.log('同步任务 2')

        requestAnimationFrame(() => {
          console.log('帧结束 ' + frameCount)
          frameCount += 1
        })
      })
/*
任务开始
  同步任务 1
  同步任务 2
	微任务 3
	微任务 4
帧结束 0
  宏任务 5
	微任务 6
帧结束 1
*/
  </script>
</body>


```

1. 浏览器会将整个按钮的回调函数作为一个宏任务执行
2. 执行同步代码打印(`任务开始`)
3. 遇到``setTimeout`，将`setTimeout`任务回调压入宏任务队列
4. 执行 new Promise 的同步任务，打印(`同步任务 1`)
5. `promise.then` 压入微任务队列
6. `promise.then` 再次压入微任务队列，此时微任务队列有两个任务
7. 执行同步代码打印(`同步任务 2`)
8. `requestAnimationFrame` 挂载一个回调函数
9. 此时同步任务执行完毕，开始执行**微任务队列**
10. `promise.then` 打印(`微任务 3`)
11. `promise.then` 打印(`微任务 4`)
12. 完成所有微任务后 执行 `requestAnimationFrame` 回调
13. 打印  `帧结束 0` (表示该帧的事件循环结束)
14. 略过第0帧的渲染、`requestIdleCallback` 等直接进入到下一帧
15. 执行`setTimeout`回调打印(`宏任务 5`)
16. 同步执行`promise.resolve()` 将 then 压入微任务队列
17. 执行同步任务 打印(`同步 6`)
18. 挂载 `requestAnimationFrame`回调
19. 执行这一帧的微任务，打印(`微任务 7`)
20. 执行 `requestAnimationFrame`回调，打印(`帧结束 1`)

其中 1-14 是第1帧发生的，15-20是下一帧才会有的。也就是说每一帧的事件循环只会执行一个宏任务和它所包括的所有微任务。



## Parse HTML

在解析 HTML 阶段，浏览器会将 HTML 代码解析成 DOM 树，以便后续的布局和渲染操作。在该阶段，浏览器会执行以下主要任务：

1. 根据 HTML 代码构建 DOM 树：浏览器会根据 HTML 代码构建 DOM 树，将 HTML 元素转换成 DOM 元素，并确定它们之间的关系。
2. 处理外部资源：浏览器会处理 HTML 中引用的外部资源，如样式表、图片、视频等，以便后续的布局和渲染操作。
3. 构建 CSSOM 树：浏览器会根据样式表构建 CSSOM 树，以便后续的样式计算和布局操作。

在解析 HTML 阶段，如果 HTML 代码包含大量的嵌套标签、重复的样式信息或大量的外部资源，可能会导致解析时间较长，影响页面的加载性能和用户体验。因此，在编写 HTML 代码时应尽可能精简，减少不必要的标签和样式信息，以提高页面的加载速度和性能。



## Recalc Styles

下一个阶段是重新样式计算（Recalc Styles）阶段。在该阶段，浏览器会根据 DOM 树和 CSSOM 树计算每个元素的样式信息，以便后续的布局和渲染操作。

在样式计算阶段，浏览器会执行以下主要任务：

1. 计算元素的样式信息：浏览器会根据 DOM 树和 CSSOM 树计算每个元素的样式信息，包括继承的样式和显示定义的样式。
2. 生成 Render 树：浏览器会根据 DOM 树和计算出的样式信息生成 Render 树，其中每个 Render 对象对应一个元素在屏幕上的可视化呈现。

在样式计算阶段，如果页面中包含复杂的 CSS 选择器、伪类和伪元素等，可能会导致样式计算时间较长，影响页面的渲染性能和用户体验。因此，在编写 CSS 代码时应尽可能简洁明了，避免过度使用复杂的选择器和样式规则。



## Layout

接下来是 Layout（布局）阶段。在该阶段，浏览器会根据 Render 树中每个元素的位置和大小信息，计算出每个元素在屏幕上的准确位置，并创建用于渲染的图层（layer）和帧缓冲（frame buffer）。

在布局阶段，浏览器会执行以下主要任务：

1. 计算元素的几何位置和大小：浏览器会根据 Render 树中每个元素的样式和内容，计算出元素在屏幕上的位置和大小。
2. 创建图层和帧缓冲：浏览器会根据元素的层级关系和其他因素，创建图层和帧缓冲，以便后续的绘制和合成操作。

在布局阶段，如果页面中包含大量的 DOM 元素、嵌套层次深或样式信息复杂的元素，可能会导致布局时间较长，影响页面的渲染性能和用户体验。因此，在编写 HTML 和 CSS 代码时应尽可能简单明了，避免过度嵌套和使用不必要的样式规则。



## Update Layer Tree

更新图层树（Update Layer Tree）的阶段。在该阶段，浏览器会根据 DOM 树和 CSSOM 树的变化，以及图层的创建和销毁等情况，更新 Render 树和图层树的结构。

在更新图层树阶段，浏览器会执行以下主要任务：

1. 更新 Render 树：浏览器会根据 DOM 树和 CSSOM 树的变化，更新 Render 树中相应元素的样式信息和位置信息。
2. 创建或销毁图层：浏览器会根据元素的层级关系和其他因素，创建或销毁相应的图层。
3. 更新图层属性：浏览器会更新每个图层的属性，例如透明度、可见性等。

更新图层树的过程比较复杂，需要考虑多种因素，例如元素的层级关系、动画效果、滚动等。如果更新图层树的频率过高，可能会导致页面的性能问题。因此，在编写 JavaScript 代码时，应尽量避免频繁地修改 DOM 树和 CSSOM 树，以减少更新图层树的次数。



## Paint

Paint(渲染) 阶段是指将元素绘制到屏幕上的阶段。在该阶段，浏览器会根据元素的布局信息、绘制属性等进行具体的绘制操作，生成位图并将其输出到屏幕上。

具体来说，Paint 阶段的主要工作包括以下几个方面：

1. 遍历布局树和图层树，确定哪些元素需要被绘制，哪些不需要。在这个过程中，浏览器会进行一些优化，如剪裁、合并相邻的绘制区域等，以减少重复的绘制操作。
2. 根据元素的绘制属性，生成对应的绘制指令（Paint Command），如填充颜色、渐变、边框、阴影、背景图片等。
3. 对于需要进行复杂绘制操作的元素，如 CSS transform、CSS filter 等，浏览器会将其交给 GPU 进行加速计算，并将结果缓存下来，以便在下一次绘制时可以直接使用。
4. 将绘制指令组合成一张位图，同时对于某些需要进行重复绘制的元素，如滚动条、渐变背景等，浏览器会采用一些特殊的技术，如 9-patch 图片等，以减少重复的绘制操作。
5. 将生成的位图输出到屏幕上，完成本次绘制操作。

需要注意的是，由于每次渲染都需要进行 Layout 和 Paint 阶段的操作，因此在开发过程中，应该尽量减少布局的改变，避免过多的重绘操作，从而提高页面的渲染效率。



## Composite 

Composite(合成) 阶段。在该阶段，浏览器会将 Paint 阶段生成的位图与之前的位图进行合成，最终生成最终的屏幕图像。这个阶段的目的是将位图**显示**在屏幕上，给用户呈现最终的渲染结果。

在 Composite 阶段，浏览器会使用 GPU 加速技术将多个层的位图合成成最终的屏幕图像。如果合成过程中出现了透明度、遮罩等特殊情况，浏览器会根据具体情况选择合适的合成方式，以保证最终的渲染结果符合用户的期望。

需要注意的是，由于在 Composite 阶段的位图合成过程中需要进行大量的计算，因此在开发过程中，应该尽量减少层的数量，避免过多的重叠，从而提高页面的渲染效率。





## requestIdleCallback

正常来说浏览器每帧到这个阶段就已经结束了，但是距离下一帧有仍然具有空闲时间，浏览器并不会因为空闲而去提高帧率，大部分浏览器都会将帧率维持在60帧左右。

requestIdleCallback 方法是在浏览器的 Event Loop 循环中调用的，它并不是渲染流程的一部分。当浏览器在处理完当前帧的所有任务后，如果有空闲时间，就会执行 requestIdleCallback 回调函数中的任务。

这个方法主要用于执行一些非关键性的任务，例如后台计算、数据处理、预加载等等，以避免这些任务对页面渲染造成阻塞。在回调函数中，开发者可以根据当前空闲时间的长度，调整任务的执行量，以充分利用空闲时间的资源，同时避免对主线程的影响。

需要注意的是，requestIdleCallback 方法的执行顺序是不确定的，并且不会保证在每个帧中都执行。因此，在使用该方法时，需要根据实际需求和性能要求来权衡使用时机和任务量，以充分发挥其优势，同时避免对页面的性能产生负面影响。