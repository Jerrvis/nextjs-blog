<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>浏览器的缓存机制<!-- -->-i21y</title><meta name="description" content="浏览器的缓存机制就是我们常说的http缓存，其机制是根据http报文的缓存标识进行的."/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/i21y.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/3f657ae3c6803ff1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3f657ae3c6803ff1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/278147bac28f99c8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/278147bac28f99c8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-348c8faa34e64ab3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-510d9c9b9e899ed3.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-0854415bcb61de7a.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_buildManifest.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="header_header__yYL2k header_h_fixed__Qa_Tq header_header_visible__4dwbr"><nav class="header_mw_container__FaoC1 mg-mid"><ul><li><a href="/">首页</a></li><li><a href="/node">机场</a></li><li><a href="/tech">技术</a></li></ul></nav></header><section class="banner_banner__IBpVz"><div class="banner_title__kJJdU"><h1>i21y</h1></div></section><div class="background_background__JxIUd"></div><div><div class="content_conatiner__cUAH5"><div class="content_route__kkvsP"><main><article class="_slug__article__97FZ4"><div class="_slug__head__AlZoJ"><h1>浏览器的缓存机制</h1><h4>2023-03-02</h4></div><div class="markdown"><p>浏览器的缓存机制就是我们常说的http缓存，其机制是根据http报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先了解一下http报文。</p>
<p>http请求报文格式为</p>
<ol>
<li>请求行</li>
<li>http头</li>
<li>空行</li>
<li>请求报文主体</li>
</ol>
<p>http 响应报文格式为</p>
<ol>
<li>状态行</li>
<li>http头</li>
<li>空行</li>
<li>响应报文主体</li>
</ol>
<h2>为什么需要浏览器缓存</h2>
<p>我们知道通过HTTP协议，在客户端和浏览器建立连接时需要消耗时间，而大的响应需要在客户端和服务器之间进行多次往返通信才能获得完整的响应，这拖延了浏览器可以使用和处理内容的时间。这就增加了访问服务器的数据和资源的成本，因此利用浏览器的缓存机制重用以前获取的数据就变成了性能优化时需要考虑的事情。</p>
<h2>浏览器的缓存过程</h2>
<p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img data-src="https://thumbsnap.com/i/EqtU5DbP.png" src="#" alt="image-20230301201112226"/></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<strong>强缓存</strong>和<strong>协商缓存</strong>。</p>
<h2>强缓存</h2>
<p>当浏览器第一次请求某个资源时，服务器会将该资源的过期时间一并返回给浏览器，并在下一次请求时比较该资源的过期时间与当前时间的差值，如果该差值小于某个特定的时间阈值，则浏览器认为该资源仍然有效，直接从本地缓存中读取该资源，不再向服务器发送请求。强缓存的优点是可以减少对服务器的请求，从而提高网页的访问速度和性能，但是它的缺点是可能导致用户看到过期的内容。</p>
<p>强缓存可以通过设置 HTTP 响应头中的 <code>Cache-Control</code> 和 <code>Expires</code> 字段来进行控制。</p>
<h3>Expires</h3>
<p>Expires: 是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p>
<h3>Cache-Control</h3>
<p>Cache-Control：是 HTTP/1.1 协议中用于控制缓存的首部字段，常用的取值包括：</p>
<ul>
<li>max-age=(seconds)：指定资源的最长缓存时间，单位为秒。</li>
<li>no-cache：指示客户端缓存该资源，但在使用之前必须经过服务器的验证。</li>
<li>no-store：指示客户端不应该缓存该资源，每次都必须从服务器获取最新的版本。</li>
</ul>
<p>Cache-Control 的优点是它不依赖于客户端和服务器的时间同步，而且可以更加灵活地控制缓存的行为。但是它的缺点是需要浏览器和服务器都支持才能生效。如果服务器返回的响应同时包含 Expires 和 Cache-Control，Cache-Control 优先级更高，浏览器会忽略 Expires。</p>
<h2>协商缓存</h2>
<p>如果强缓存失效，浏览器会向服务器发送一个请求，服务器会返回资源的最后修改时间和一个唯一的标识符（如 ETag），浏览器会将这些信息保存到本地，并在下一次请求时将它们发送给服务器，如果该资源未发生变化，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。协商缓存的优点是可以避免强缓存导致用户看到过期的内容，但是它的缺点是需要与服务器进行通信，从而增加网络传输的时间和成本。</p>
<p><img data-src="https://thumbsnap.com/i/DZvA8sY4.png" src="#" alt="image-20230301195448090"/></p>
<p>如果资源发生更新了，则会返回200和请求结果，浏览器会重新将请求结果和缓存标识存入浏览器缓存中</p>
<p>协商缓存的字段主要包括两个：Last-Modified 和 ETag。</p>
<h3>Last-Modified</h3>
<p>Last-Modified 是一个时间戳，表示该资源的最后修改时间，服务器在返回该资源时会将该时间戳一并返回给浏览器。当浏览器再次请求该资源时，会将该时间戳发送给服务器，服务器会比较该时间戳与该资源的最后修改时间，如果它们相同，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。</p>
<h3>ETag</h3>
<p>ETag 是一个唯一的字符串，表示该资源的唯一标识符，服务器在返回该资源时会将该字符串一并返回给浏览器。当浏览器再次请求该资源时，会将该字符串发送给服务器，服务器会比较该字符串与该资源的唯一标识符，如果它们相同，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。</p>
<p>Last-Modified 和 ETag 的优点是它们可以更加准确地控制缓存的行为，即使该资源的内容没有发生变化，只要它的 Last-Modified 或 ETag 发生变化，浏览器也会向服务器发送请求。但是它们的缺点是会增加服务器的负担，并且会导致缓存的响应时间变长。如果服务器返回的响应同时包含 Last-Modified 和 ETag，ETag 优先级更高，浏览器会忽略 Last-Modified。</p>
<h2>注意问题</h2>
<p>需要注意的是，有些资源可能不适合被缓存，例如动态生成的内容、登录信息等，此时可以通过设置相应的 HTTP 头信息（如 Cache-Control 和 Pragma）来禁用缓存。</p></div></article></main></div><aside class="content_aside__MopO6"><div class="content_part1__jZT52"><div class="content_author_state__Lrpt3"><img alt="author_image" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="content_author_image__z5bT6" style="color:transparent" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75"/><h5>jkun</h5><h6>打工人</h6></div><nav></nav></div></aside></div></div><footer class="footer_footer__l5XV_ mg-mid"><div class="footer_info__oLZT6"><div>Copyright © 2022-2023 Jkun</div><div>Design By Jkun</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"浏览器的缓存机制","date":"2023-03-02","description":"浏览器的缓存机制就是我们常说的http缓存，其机制是根据http报文的缓存标识进行的.","tags":["interview","browser"],"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    ol: \"ol\",\n    li: \"li\",\n    h2: \"h2\",\n    img: \"img\",\n    ul: \"ul\",\n    code: \"code\",\n    strong: \"strong\",\n    h3: \"h3\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"浏览器的缓存机制就是我们常说的http缓存，其机制是根据http报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先了解一下http报文。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"http请求报文格式为\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"请求行\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"http头\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"空行\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求报文主体\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"http 响应报文格式为\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"状态行\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"http头\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"空行\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应报文主体\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"为什么需要浏览器缓存\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我们知道通过HTTP协议，在客户端和浏览器建立连接时需要消耗时间，而大的响应需要在客户端和服务器之间进行多次往返通信才能获得完整的响应，这拖延了浏览器可以使用和处理内容的时间。这就增加了访问服务器的数据和资源的成本，因此利用浏览器的缓存机制重用以前获取的数据就变成了性能优化时需要考虑的事情。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"浏览器的缓存过程\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/EqtU5DbP.png\",\n        alt: \"image-20230301201112226\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"由上图我们可以知道：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"浏览器每次发起请求，都会\", _jsx(_components.code, {\n          children: \"先在浏览器缓存中查找该请求的结果以及缓存标识\"\n        })]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"浏览器每次拿到返回的请求结果都会\", _jsx(_components.code, {\n          children: \"将该结果和缓存标识存入浏览器缓存中\"\n        })]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是\", _jsx(_components.strong, {\n        children: \"强缓存\"\n      }), \"和\", _jsx(_components.strong, {\n        children: \"协商缓存\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"强缓存\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当浏览器第一次请求某个资源时，服务器会将该资源的过期时间一并返回给浏览器，并在下一次请求时比较该资源的过期时间与当前时间的差值，如果该差值小于某个特定的时间阈值，则浏览器认为该资源仍然有效，直接从本地缓存中读取该资源，不再向服务器发送请求。强缓存的优点是可以减少对服务器的请求，从而提高网页的访问速度和性能，但是它的缺点是可能导致用户看到过期的内容。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"强缓存可以通过设置 HTTP 响应头中的 \", _jsx(_components.code, {\n        children: \"Cache-Control\"\n      }), \" 和 \", _jsx(_components.code, {\n        children: \"Expires\"\n      }), \" 字段来进行控制。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Expires\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Expires: 是HTTP/1.0控制网页缓存的字段，其值为服务器返回该请求结果\", _jsx(_components.code, {\n        children: \"缓存的到期时间\"\n      }), \"，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Cache-Control\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cache-Control：是 HTTP/1.1 协议中用于控制缓存的首部字段，常用的取值包括：\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"max-age=(seconds)：指定资源的最长缓存时间，单位为秒。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"no-cache：指示客户端缓存该资源，但在使用之前必须经过服务器的验证。\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"no-store：指示客户端不应该缓存该资源，每次都必须从服务器获取最新的版本。\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Cache-Control 的优点是它不依赖于客户端和服务器的时间同步，而且可以更加灵活地控制缓存的行为。但是它的缺点是需要浏览器和服务器都支持才能生效。如果服务器返回的响应同时包含 Expires 和 Cache-Control，Cache-Control 优先级更高，浏览器会忽略 Expires。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"协商缓存\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果强缓存失效，浏览器会向服务器发送一个请求，服务器会返回资源的最后修改时间和一个唯一的标识符（如 ETag），浏览器会将这些信息保存到本地，并在下一次请求时将它们发送给服务器，如果该资源未发生变化，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。协商缓存的优点是可以避免强缓存导致用户看到过期的内容，但是它的缺点是需要与服务器进行通信，从而增加网络传输的时间和成本。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/DZvA8sY4.png\",\n        alt: \"image-20230301195448090\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如果资源发生更新了，则会返回200和请求结果，浏览器会重新将请求结果和缓存标识存入浏览器缓存中\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"协商缓存的字段主要包括两个：Last-Modified 和 ETag。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"Last-Modified\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Last-Modified 是一个时间戳，表示该资源的最后修改时间，服务器在返回该资源时会将该时间戳一并返回给浏览器。当浏览器再次请求该资源时，会将该时间戳发送给服务器，服务器会比较该时间戳与该资源的最后修改时间，如果它们相同，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"ETag\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"ETag 是一个唯一的字符串，表示该资源的唯一标识符，服务器在返回该资源时会将该字符串一并返回给浏览器。当浏览器再次请求该资源时，会将该字符串发送给服务器，服务器会比较该字符串与该资源的唯一标识符，如果它们相同，则服务器会返回一个 304 Not Modified 响应，告诉浏览器可以直接从本地缓存中读取该资源。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Last-Modified 和 ETag 的优点是它们可以更加准确地控制缓存的行为，即使该资源的内容没有发生变化，只要它的 Last-Modified 或 ETag 发生变化，浏览器也会向服务器发送请求。但是它们的缺点是会增加服务器的负担，并且会导致缓存的响应时间变长。如果服务器返回的响应同时包含 Last-Modified 和 ETag，ETag 优先级更高，浏览器会忽略 Last-Modified。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"注意问题\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"需要注意的是，有些资源可能不适合被缓存，例如动态生成的内容、登录信息等，此时可以通过设置相应的 HTTP 头信息（如 Cache-Control 和 Pragma）来禁用缓存。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"browsercache"},"buildId":"Y8_bobxTipRy7oK9ZhkS4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>