<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>浏览器输入url回车后发生了什么？<!-- -->-i21y</title><meta name="description" content="前端面试0：浏览器输入url回车后发生了什么。该问题涉及到多方面的内容，包括网络的七层模型、浏览器缓存机制、tcp、udp、http/https、浏览器的渲染机制等。"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/i21y.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/3f657ae3c6803ff1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3f657ae3c6803ff1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/278147bac28f99c8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/278147bac28f99c8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-348c8faa34e64ab3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-510d9c9b9e899ed3.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-0854415bcb61de7a.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_buildManifest.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="header_header__yYL2k header_h_fixed__Qa_Tq header_header_visible__4dwbr"><nav class="header_mw_container__FaoC1 mg-mid"><ul><li><a href="/">首页</a></li><li><a href="/node">机场</a></li><li><a href="/tech">技术</a></li></ul></nav></header><section class="banner_banner__IBpVz"><div class="banner_title__kJJdU"><h1>i21y</h1></div></section><div class="background_background__JxIUd"></div><div><div class="content_conatiner__cUAH5"><div class="content_route__kkvsP"><main><article class="_slug__article__97FZ4"><div class="_slug__head__AlZoJ"><h1>浏览器输入url回车后发生了什么？</h1><h4>2023-02-27</h4></div><div class="markdown"><h2>1. 缓存查询</h2>
<p>首先会去查询浏览器缓存或者本地缓存，查询是否有域名的dns记录，有就使用缓存直接向网址对应的ip发送请求</p>
<p>详细可查看我的文章：<a href="./browsercache">浏览器的缓存机制</a></p>
<h2>2. 查看hosts映射</h2>
<p>然后前往本地的hosts文件里查看是否有域名相关的映射</p>
<p>以我的win10为例具体路径为 <code>c:\Windows\System32\drivers\etc\HOSTS</code></p>
<p>文件内容为如下</p>
<p><img data-src="https://thumbsnap.com/i/vjHK1gkX.png" src="#" alt="image-20230301223216346"/></p>
<p>这些github.com都是我自己手动设置的，也是为了更好地访问 github 设置了一些的ip，具体设置方法就不展开讲了，可自行百度。</p>
<h2>3. dns解析</h2>
<h3>3.1 打包请求</h3>
<p>如果hosts文件中也没有的话，浏览器会打包一个请求内容是<strong>查询某度ip</strong>，它会把请求发送到电脑中配置好的 dns 服务器 8.8.8.8</p>
<p>这个请求会由多层的网络协议封装，传输层添加一个随机端口，比如源端口:167 目标端口:53(dns通常使用53作为端口)，网络层添加ip(源ip:192.168.1.11 和目标ip: 8.8.8.8)，数据链路层添加MAC地址，AA-AA-AA-AA 发送给 CC-CC-CC-CC(以下简写为AA-CC)。</p>
<h3>3.2 路由器转发公网</h3>
<p>然后这个请求经过网关发送到局域网的路由器中，路由器通过MAC地址接收了这个请求后，查看到是发送给 8.8.8.8 ip，它会做一个转换将这个请求的源ip与端口 192.168.1.11:167 换成自己的公网ip与随机端口 : 172.12.34.56:857，并记录下映射 ( 172.12.34.56:857=&gt; 192.168.1.11:167)，重新添加本机的公网源MAC地址(DD-DD-DD-DD)与它的下一个路由器地址(EE-EE-EE-EE 随便写的)，我们把它简写成这样子(DD-EE)，然后把请求发送到公网上。</p>
<h3>3.3 公网转发</h3>
<p>公网的EE的路由器接收到这个请求后，会修改源与目标MAC地址，改成EE-FF(FF为下一个路由器的地址)，经过不知道多少个路由器后变成了ZZ-FF来到了dns服务器</p>
<h3>3.4  到达dns服务器</h3>
<p>FF服务器看到是发给自己的请求，查看端口号是53(dns默认53端口)，然后dns服务器会进行dns解析，查到<strong>某度的ip 是 11.11.11.11</strong>，然后生成一个响应，源ip端口是 8.8.8.8:53，目标ip端口 172.12.34.56:857,原路返回。</p>
<h3>3.5 返回到路由器</h3>
<p>返回时同样经过多轮的MAC地址更换 最后变成EE-DD (EE发给DD)，来到了本地路由器(DD)。</p>
<h3>3.6 路由器转换</h3>
<p>路由器再次进行NAT转换 在记录的映射里找到 ip端口172.12.34.56:857是 发送给 192.168.1.11:167，转换后再次添加局域网MAC 地址与目标 MAC地址 CC-AA，然后这个响应经过交换机回到 电脑(AA)</p>
<h3>3.7 得到ip地址</h3>
<p>电脑查看是 8.8.8.8发送回来的，查看端口 167 是浏览器开的端口，就把信息发送到浏览器，浏览器查看信息到某度的ip 是 11.11.11.11.</p>
<h2>4 向目标ip建立链接</h2>
<p>与目标ip服务器使用tcp协议，三次握手建立连接。</p>
<h2>5 发送http/https请求</h2>
<p>三次握手之后，浏览器会发送请求，内容是<strong>请把某度首页数据给我</strong>，流程跟刚才向dns发送请求差不多只不过目标ip 换成某度的ip 11.11.11.11端口为80(此时浏览器并不知道该网址是否使用https，所以默认使用http 默认端口 80)。</p>
<p>当某度服务器80端口获取到你请求，以nginx为例，它会设置80端口重定向到443端口(https默认端口号)</p>
<p>我用 firefox 浏览器与bilibili.com测试(我很少用firefox)，我从没使用过firefox 浏览 bilibili.com，所以浏览器不知道要走https。</p>
<p>可以看到第一个请求走的http发生了301重定向到 https</p>
<p><img data-src="https://thumbsnap.com/i/FmZW1mCe.png" src="#" alt="image-20230226214921104"/></p>
<p>第二个请求才是走的https</p>
<p><img data-src="https://thumbsnap.com/i/APz5xwtk.png" src="#" alt="image-20230226215026057"/></p>
<p>然后我们再开一个页面再次打开bilibili.com</p>
<p>它直接走https了</p>
<p><img data-src="https://thumbsnap.com/i/ShvnuCma.png" src="#" alt="image-20230226215318867"/></p>
<p>接下来关闭所有页面，按下 ctrl + shift + h 删除掉bilibili的记录</p>
<p><img data-src="https://thumbsnap.com/i/ARyXa59N.png" src="#" alt="image-20230226215525329"/></p>
<p>重新打开 bilibili.com 浏览器又走的http了</p>
<p><img data-src="https://thumbsnap.com/i/RB8ZJrmp.png" src="#" alt="image-20230226215826544"/></p>
<h2>6 服务器处理请求并返回http报文</h2>
<p>服务器收到请求后会发出应答，即响应数据。HTTP响应与HTTP请求相似， HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。</p>
<h2>7 浏览器解析渲染页面</h2>
<p>浏览器拿到响应文本后，解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：</p>
<p>(1)根据HTML文件解析出DOM Tree</p>
<p>(2)根据CSS解析出 CSSOM Tree(CSS规则树)</p>
<p>(3)将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)</p>
<p>(4)reflow(重排)：根据Render tree进行节点信息计算(Layout)</p>
<p>(5)repaint(重绘)：根据计算好的信息绘制整个页面(Painting)</p>
<p>因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 <strong>JS 代码应该放在 html 代码的后面</strong>。</p>
<h2>8 TCP四次挥手</h2>
<p>当数据传输完毕，需要断开TCP连接，此时发起tcp四次挥手</p>
<p>第一次挥手是浏览器发完数据后，发送FIN请求断开连接。</p>
<p>第二次挥手是服务器发送ACK表示同意</p>
<p>第三次挥手是服务器发送FIN，表示现在关闭</p>
<p>这样浏览器需要返回ACK表示同意，也就是第四次挥手。</p>
<p>面试官追问：</p>
<ol>
<li>网页的缓存机制</li>
<li>七层网络协议是什么</li>
<li>http/https 相关问题</li>
<li>浏览器渲染机制</li>
<li>回流与重绘</li>
</ol></div></article></main></div><aside class="content_aside__MopO6"><div class="content_part1__jZT52"><div class="content_author_state__Lrpt3"><img alt="author_image" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="content_author_image__z5bT6" style="color:transparent" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75"/><h5>jkun</h5><h6>打工人</h6></div><nav></nav></div></aside></div></div><footer class="footer_footer__l5XV_ mg-mid"><div class="footer_info__oLZT6"><div>Copyright © 2022-2023 Jkun</div><div>Design By Jkun</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"浏览器输入url回车后发生了什么？","date":"2023-02-27","description":"前端面试0：浏览器输入url回车后发生了什么。该问题涉及到多方面的内容，包括网络的七层模型、浏览器缓存机制、tcp、udp、http/https、浏览器的渲染机制等。","tags":["interview","browser"],"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    a: \"a\",\n    code: \"code\",\n    img: \"img\",\n    h3: \"h3\",\n    strong: \"strong\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"1. 缓存查询\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"首先会去查询浏览器缓存或者本地缓存，查询是否有域名的dns记录，有就使用缓存直接向网址对应的ip发送请求\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"详细可查看我的文章：\", _jsx(_components.a, {\n        href: \"./browsercache\",\n        children: \"浏览器的缓存机制\"\n      })]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"2. 查看hosts映射\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后前往本地的hosts文件里查看是否有域名相关的映射\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"以我的win10为例具体路径为 \", _jsx(_components.code, {\n        children: \"c:\\\\Windows\\\\System32\\\\drivers\\\\etc\\\\HOSTS\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"文件内容为如下\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/vjHK1gkX.png\",\n        alt: \"image-20230301223216346\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这些github.com都是我自己手动设置的，也是为了更好地访问 github 设置了一些的ip，具体设置方法就不展开讲了，可自行百度。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"3. dns解析\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.1 打包请求\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果hosts文件中也没有的话，浏览器会打包一个请求内容是\", _jsx(_components.strong, {\n        children: \"查询某度ip\"\n      }), \"，它会把请求发送到电脑中配置好的 dns 服务器 8.8.8.8\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个请求会由多层的网络协议封装，传输层添加一个随机端口，比如源端口:167 目标端口:53(dns通常使用53作为端口)，网络层添加ip(源ip:192.168.1.11 和目标ip: 8.8.8.8)，数据链路层添加MAC地址，AA-AA-AA-AA 发送给 CC-CC-CC-CC(以下简写为AA-CC)。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.2 路由器转发公网\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后这个请求经过网关发送到局域网的路由器中，路由器通过MAC地址接收了这个请求后，查看到是发送给 8.8.8.8 ip，它会做一个转换将这个请求的源ip与端口 192.168.1.11:167 换成自己的公网ip与随机端口 : 172.12.34.56:857，并记录下映射 ( 172.12.34.56:857=\u003e 192.168.1.11:167)，重新添加本机的公网源MAC地址(DD-DD-DD-DD)与它的下一个路由器地址(EE-EE-EE-EE 随便写的)，我们把它简写成这样子(DD-EE)，然后把请求发送到公网上。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.3 公网转发\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"公网的EE的路由器接收到这个请求后，会修改源与目标MAC地址，改成EE-FF(FF为下一个路由器的地址)，经过不知道多少个路由器后变成了ZZ-FF来到了dns服务器\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.4  到达dns服务器\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"FF服务器看到是发给自己的请求，查看端口号是53(dns默认53端口)，然后dns服务器会进行dns解析，查到\", _jsx(_components.strong, {\n        children: \"某度的ip 是 11.11.11.11\"\n      }), \"，然后生成一个响应，源ip端口是 8.8.8.8:53，目标ip端口 172.12.34.56:857,原路返回。\"]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.5 返回到路由器\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"返回时同样经过多轮的MAC地址更换 最后变成EE-DD (EE发给DD)，来到了本地路由器(DD)。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.6 路由器转换\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"路由器再次进行NAT转换 在记录的映射里找到 ip端口172.12.34.56:857是 发送给 192.168.1.11:167，转换后再次添加局域网MAC 地址与目标 MAC地址 CC-AA，然后这个响应经过交换机回到 电脑(AA)\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"3.7 得到ip地址\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"电脑查看是 8.8.8.8发送回来的，查看端口 167 是浏览器开的端口，就把信息发送到浏览器，浏览器查看信息到某度的ip 是 11.11.11.11.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"4 向目标ip建立链接\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"与目标ip服务器使用tcp协议，三次握手建立连接。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"5 发送http/https请求\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"三次握手之后，浏览器会发送请求，内容是\", _jsx(_components.strong, {\n        children: \"请把某度首页数据给我\"\n      }), \"，流程跟刚才向dns发送请求差不多只不过目标ip 换成某度的ip 11.11.11.11端口为80(此时浏览器并不知道该网址是否使用https，所以默认使用http 默认端口 80)。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当某度服务器80端口获取到你请求，以nginx为例，它会设置80端口重定向到443端口(https默认端口号)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"我用 firefox 浏览器与bilibili.com测试(我很少用firefox)，我从没使用过firefox 浏览 bilibili.com，所以浏览器不知道要走https。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"可以看到第一个请求走的http发生了301重定向到 https\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/FmZW1mCe.png\",\n        alt: \"image-20230226214921104\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第二个请求才是走的https\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/APz5xwtk.png\",\n        alt: \"image-20230226215026057\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"然后我们再开一个页面再次打开bilibili.com\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"它直接走https了\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/ShvnuCma.png\",\n        alt: \"image-20230226215318867\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"接下来关闭所有页面，按下 ctrl + shift + h 删除掉bilibili的记录\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/ARyXa59N.png\",\n        alt: \"image-20230226215525329\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"重新打开 bilibili.com 浏览器又走的http了\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"https://thumbsnap.com/i/RB8ZJrmp.png\",\n        alt: \"image-20230226215826544\"\n      })\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"6 服务器处理请求并返回http报文\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"服务器收到请求后会发出应答，即响应数据。HTTP响应与HTTP请求相似， HTTP响应报文格式：状态行+响应头+空行+消息体，状态行包括HTTP版本号、状态码、状态说明。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"7 浏览器解析渲染页面\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"浏览器拿到响应文本后，解析HTML代码，请求js，css等资源，最后进行页面渲染，呈现给用户。页面渲染一般分为以下几个步骤：\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(1)根据HTML文件解析出DOM Tree\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(2)根据CSS解析出 CSSOM Tree(CSS规则树)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(3)将 DOM Tree 和 CSSOM Tree合并，构建Render tree(渲染树)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(4)reflow(重排)：根据Render tree进行节点信息计算(Layout)\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"(5)repaint(重绘)：根据计算好的信息绘制整个页面(Painting)\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因为 html 是一个树形结构，浏览器根据这个 html 来构建 DOM 树，在 dom 树的构建过程中如果遇到 JS 脚本和外部 JS 连接，则会停止构建 DOM 树来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐 \", _jsx(_components.strong, {\n        children: \"JS 代码应该放在 html 代码的后面\"\n      }), \"。\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"8 TCP四次挥手\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"当数据传输完毕，需要断开TCP连接，此时发起tcp四次挥手\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第一次挥手是浏览器发完数据后，发送FIN请求断开连接。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第二次挥手是服务器发送ACK表示同意\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"第三次挥手是服务器发送FIN，表示现在关闭\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这样浏览器需要返回ACK表示同意，也就是第四次挥手。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"面试官追问：\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"网页的缓存机制\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"七层网络协议是什么\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"http/https 相关问题\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"浏览器渲染机制\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"回流与重绘\"\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"inputurl"},"buildId":"Y8_bobxTipRy7oK9ZhkS4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>