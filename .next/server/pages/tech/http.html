<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>http/https(更新中)<!-- -->-i21y</title><meta name="description" content="前端面试1：http/https都是什么，它们的区别和作用。"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="icon" href="/i21y.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/3f657ae3c6803ff1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3f657ae3c6803ff1.css" data-n-g=""/><link rel="preload" href="/_next/static/css/278147bac28f99c8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/278147bac28f99c8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-8fa1640cc84ba8fe.js" defer=""></script><script src="/_next/static/chunks/framework-2c79e2a64abdb08b.js" defer=""></script><script src="/_next/static/chunks/main-348c8faa34e64ab3.js" defer=""></script><script src="/_next/static/chunks/pages/_app-510d9c9b9e899ed3.js" defer=""></script><script src="/_next/static/chunks/pages/tech/%5Bslug%5D-0854415bcb61de7a.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_buildManifest.js" defer=""></script><script src="/_next/static/Y8_bobxTipRy7oK9ZhkS4/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="header_header__yYL2k header_h_fixed__Qa_Tq header_header_visible__4dwbr"><nav class="header_mw_container__FaoC1 mg-mid"><ul><li><a href="/">首页</a></li><li><a href="/node">机场</a></li><li><a href="/tech">技术</a></li></ul></nav></header><section class="banner_banner__IBpVz"><div class="banner_title__kJJdU"><h1>i21y</h1></div></section><div class="background_background__JxIUd"></div><div><div class="content_conatiner__cUAH5"><div class="content_route__kkvsP"><main><article class="_slug__article__97FZ4"><div class="_slug__head__AlZoJ"><h1>http/https(更新中)</h1><h4>2023-03-02</h4></div><div class="markdown"><h2>tcp</h2>
<p>http 协议是建立在 tcp 协议之上的。http 协议位于应用层，而tcp是在传输层的协议。</p>
<h2>http</h2>
<p>HTTP (Hypertext Transfer Protocol)又名超文本传输协议，是一种用于传输Web页面和其他资源的协议。HTTP使用客户端-服务器模型，并通过Internet进行通信。当用户在Web浏览器中输入URL时，浏览器向Web服务器发出HTTP请求。Web服务器然后返回HTTP响应，其中包含请求的数据。HTTP协议是一个无状态协议，这意味着服务器不会在请求之间保留任何状态信息。</p>
<p>协议内容包括三个部分：<strong>超文本</strong>、<strong>传输</strong>、<strong>协议</strong></p>
<h3>超文本</h3>
<p>HTTP 传输的内容是「超文本」，字面意思就是超越了基本文字内容各种互联网内容，包括图片、音频、视频、压缩包、文件等，都是HTTP的「超文本」，这些内容都可以通过浏览器渲染展现出来。</p>
<h3>传输</h3>
<p>传输的过程是双向的，客户端能向服务端发送请求，服务端接收到请求后能够响应并返回数据。</p>
<h3>协议</h3>
<p>就是预先设定的一种规范，用于计算机的通信，规范了内容的结构、行为、错误处理机制等。</p>
<h2>特点</h2>
<ul>
<li>HTTP是一种<strong>无连接</strong>协议：每一次请求都要连接一次，请求结束就会断掉，不会保持连接</li>
<li>HTTP是一种<strong>无状态</strong>协议：这意味着服务器不会在请求之间保留任何状态信息。例如，如果您第一次访问某个网站并登录，那么在您的下一次访问时，服务器将不知道您曾经登录过。为了保留这种状态信息，Web应用程序通常会使用cookie或会话等机制</li>
<li>HTTP使用<strong>请求-响应</strong>模型：客户端（通常是Web浏览器）发送一个HTTP请求到服务器，服务器将返回一个HTTP响应。HTTP请求和响应都包含头部信息和一个可选的消息体。请求头部包含有关请求的元数据，例如请求的方法（GET，POST，PUT等），请求的资源路径，以及可能包含的Cookie或其他信息。响应头部包含有关响应的元数据，例如响应的状态码（例如200 OK表示成功，404 Not Found表示资源未找到等），响应的数据类型和长度等。消息体通常包含请求或响应的有效载荷，例如HTML页面或JSON数据。</li>
<li>HTTP是一种<strong>文本</strong>协议：HTTP协议的头部和消息体都是文本格式的。这使得HTTP协议具有可读性，并且容易在网络中进行调试和诊断。然而，这也使得HTTP协议在传输大量数据时效率较低。为了提高性能，HTTP/2采用了二进制格式。</li>
<li><strong>简单快速</strong>：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快</li>
</ul>
<h2>缺点</h2>
<ul>
<li><strong>无状态</strong>：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大</li>
<li><strong>不安全</strong>：<code>明文传输</code>可能被窃听不安全，缺少<code>身份认证</code>也可能遭遇伪装，还有缺少<code>报文完整性验证</code>可能遭到篡改</li>
<li><strong>明文传输</strong>：报文(header部分)使用的是明文，直接将信息暴露给了外界，<code>WIFI陷阱</code>就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息</li>
<li><strong>队头阻塞</strong>：开启<code>长连接</code>时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)</li>
</ul>
<h2>HTTP协议结构</h2>
<p>HTTP协议的报文结构：<code>start-line</code>(请求/状态行)、<code>header</code>(请求/响应头)、<code>body</code>(请求/响应体)</p>
<ul>
<li>请求行：包含http方法，请求地址，http协议以及版本</li>
<li>状态行：包含http协议及版本、数字状态码、状态码英文名称</li>
<li>请求头/响应头：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等</li>
<li>请求体：请求的参数</li>
<li>响应体：服务端返回的数据</li>
</ul>
<h2>http 请求方法</h2>
<p><strong>HTTP1.0：</strong> <code>GET</code>、<code>POST</code>、<code>HEAD</code></p>
<p><strong>HTTP1.1：</strong> <code>PUT</code>、<code>PATCH</code>、<code>DELETE</code>、<code>OPTIONS</code>、<code>TRACE</code>、<code>CONNECT</code></p>
<table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输资源，通常会造成服务器资源的修改</td></tr><tr><td>HEAD</td><td>获得报文首部</td></tr><tr><td>PUT</td><td>更新资源</td></tr><tr><td>PATCH</td><td>对PUT的补充，对已知资源部分更新 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fhttp%2Fhttp-methods.html" target="_blank" rel="nofollow noopener noreferrer">菜鸟</a></td></tr><tr><td>DELETE</td><td>删除资源</td></tr><tr><td>OPTIONS</td><td>列出请求资源支持的请求方法，用来跨域请求</td></tr><tr><td>TRACE</td><td>追踪请求/响应路径，用于测试或诊断</td></tr><tr><td>CONNECT</td><td>将连接改为管道方式用于代理服务器(<code>隧道代理</code>下面有讲)</td></tr></tbody></table>
<hr/>
<h2>常见的http状态</h2>
<ul>
<li>200：请求成功</li>
<li>206： 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时</li>
<li>301：永久重定向</li>
<li>302：临时重定向</li>
<li>304：资源未被修改(协商缓存)</li>
<li>400：请求语法错误</li>
<li>401：没有访问权限</li>
<li>403： 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时</li>
<li>404： 请求资源不存在</li>
<li>500： 服务器内部错误，无法完成请求</li>
<li>503： 请求未完成，因服务器过载、宕机或维护等</li>
</ul>
<p>通常来说 200-399 之间都是正常的请求的状态。</p>
<hr/>
<h2>长连接</h2>
<p><code>http1.0</code>协议采用的是&quot;请求-应答&quot;模式，当使用普通模式，每次链接后只能发送一次的请求与应答，然后就要 tcp四次挥手 断开连接 ，如果要发送多次的请求，就要多次tcp握手与挥手。这也造成性能与资源的浪费。</p>
<p>因此在<code>http1.1</code>版本开始支持<strong>长连接</strong>。在请求头添加<code>Connection: Keep-Alive</code>，建立tcp连接后，可以发送多个请求与响应，实现一次握手，多次请求/响应。</p>
<p>但是长连接可能会导致资源浪费，长时间连接可能会占用服务器的资源，因为连接保持打开的时间越长，服务器就需要保留越多的资源，例如内存和文件描述符等。</p>
<p>如果服务端并发连接数过多也可能导致<strong>队头阻塞</strong></p>
<p>服务端可能需要进行连接管理：如果服务端并发连接数过多，可能需要进行连接管理以防止资源耗尽。例如，服务端可以通过限制连接的最大数量或关闭不活动的连接来管理长连接。这需要额外的开销来处理连接管理。</p>
<p>因此服务端需要设置长连接超时时间，长连接请求次数上线</p>
<h2>管道化</h2>
<p>在http1.1 的长连接情况下它是支持<strong>管道化</strong>的</p>
<p>如下为正常的请求/响应顺序</p>
<ol>
<li>请求1</li>
<li>响应1</li>
<li>请求2</li>
<li>响应2</li>
<li>请求3</li>
<li>响应3</li>
</ol>
<p>而管道化的请求/响应顺序可以变成这样</p>
<ol>
<li>请求1</li>
<li>请求2</li>
<li>请求3</li>
<li>响应1</li>
<li>响应2</li>
<li>响应3</li>
</ol>
<p><code>管线化</code>是在同一个TCP连接里<strong>发一个请求后不必等其回来就可以继续发请求出去</strong>，这可以减少整体的响应时间，但是服务器还是<strong>会按照请求的顺序响应</strong>请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题<strong>队头堵塞</strong></p>
<p><strong>队头阻塞</strong></p>
<p>队头阻塞问题（Head-of-Line Blocking）指的是在HTTP1.1中，由于HTTP请求必须按顺序一个接一个地发送和接收，如果前一个请求响应较慢，那么后续请求就会被阻塞，等待前一个请求完成后才能处理。这种情况下，即使后续请求的响应已经准备好，也必须等待前一个请求的响应完成后才能进行处理，从而导致了阻塞。</p>
<p>这个问题的根本原因是HTTP/1.1使用了串行的请求和响应模型。在这种模型中，每个HTTP请求必须等待前一个HTTP请求的响应完成后才能进行处理，而响应速度较慢的请求将会阻塞后续请求的处理。由于HTTP请求和响应的顺序是不能改变的，因此无法通过增加带宽或调整网络拓扑来解决这个问题。</p>
<p>为了解决队头阻塞问题，HTTP/2采用了二进制协议、多路复用和头部压缩等技术。多路复用允许在同一TCP连接上同时处理多个HTTP请求和响应，而不必按照严格的顺序进行处理。这样，即使某个请求的响应速度较慢，其他请求也可以继续进行处理，从而减少了阻塞的风险。头部压缩技术可以减小HTTP头部的大小，从而减少网络传输的数据量。二进制协议则可以更高效地处理数据，从而提高了性能。这些技术的综合应用，使得HTTP/2能够克服队头阻塞问题，并提高了Web应用程序的性能。</p>
<hr/>
<h2>https</h2>
<p>https 是超文本传输安全协议，即http+SSL/TLS。</p>
<p>它在http应用层下面添加了一个安全层</p>
<ol>
<li>应用层 http</li>
<li><strong>安全层 SSL/TLS</strong></li>
<li>传输层 tcp</li>
<li>网络层 ip</li>
<li>数据链路层</li>
</ol>
<p>想要弄清楚https，先搞懂什么是SSL/TLS</p>
<h3>SSL/TLS</h3>
<p>SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）是一组用于保护网络通信安全的协议。它们的主要功能是通过加密数据传输和认证双方身份来确保通信的安全性。</p>
<p>在网络通信中，数据通常是明文传输的，这使得数据容易受到窃听和篡改的攻击。为了解决这个问题，SSL/TLS使用加密技术来保护数据传输的机密性和完整性。具体来说，它们使用公钥加密技术来加密数据传输，以确保只有具有正确密钥的人可以读取数据。此外，SSL/TLS还使用数字证书来认证通信双方的身份，防止中间人攻击和欺骗。</p>
<p>SSL最初是由Netscape公司开发的，用于保护Web浏览器和Web服务器之间的通信。TLS是SSL的继任者，它是一种开放标准，由IETF（Internet Engineering Task Force，互联网工程任务组）维护和更新。TLS可以用于保护各种类型的网络通信，包括电子邮件、文件传输和即时消息等。</p>
<p>SSL和TLS的版本包括SSL 2.0、SSL 3.0、TLS 1.0、TLS 1.1、TLS 1.2和TLS 1.3。其中，SSL 2.0和SSL 3.0已经不安全，不再推荐使用。TLS 1.0、TLS 1.1和TLS 1.2已经广泛使用，而TLS 1.3是最新版本，增强了安全性和性能。</p>
<h3>RSA</h3>
<p>https 使用的是 RSA(非对称加密)。即是用公钥加密信息，只能使用私钥才能解开。</p>
<p>私钥是服务器自己生成并保存的，而公钥是通过私钥生成的。</p>
<p>通常服务器生成好公私钥后，会把公钥发送到ca机构来给网站的域名申请证书。</p>
<p>CA机构会发送一些信息，要求服务器将这些信息在放在网站首页来证明域名是属于该服务器使用的，一段时间后CA机构会访问网站确认。</p>
<p>确认完成后会颁发证书给该域名。</p>
<h3>https请求</h3>
<p>客户端发送一个https请求给服务器时，服务器收到请求后会先发送一个证书给客户端。客户端会验证证书。</p>
<p>验证完成后，客户端会随机生成一个AES(对称加密)的密钥，并使用证书的公钥对AES密钥进行加密，然后发送到服务器。</p>
<p>服务器通过RSA私钥对信息进行解密，能够获取到AES密钥。</p>
<p>此后服务端和客户端使用AES来进行信息的加密与解密(因为一直使用RSA加密会存在效率问题)。</p>
<h3>中间人攻击</h3>
<p>为什么网站需要去CA机构申请证书。因为如果没有验证的话，就可能被<code>中间人劫持</code>，假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器。</p>
<p>因此客户端需要在获取到证书的时候，会查看该证书的颁发机构，然后去浏览器或操作系统中找该机构的证书。如果找到了，或用户确认使用该证书。就会拿上级证书的公钥，解密本级证书，得到数字指纹。然后对本级证书的公钥进行数字摘要算法（证书中提供的指纹加密算法）计算结果，与解密得到的指纹对比。如果一样，说明证书没有被修改过。公钥可以放心使用，可以开始握手通信了。</p>
<h3>HTTPS优缺点</h3>
<p><strong>优点</strong></p>
<ul>
<li>内容加密，中间无法查看原始内容</li>
<li>身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持</li>
<li>数据完整性，防止内容被第三方冒充或篡改</li>
<li>虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>要钱，功能越强大的证书费用越贵</li>
<li>证书需要绑定IP，不能在同一个IP上绑定多个域名</li>
<li>https双方加解密，耗费更多服务器资源</li>
<li>https握手更耗时，降低一定用户访问速度(优化好就不是缺点了)</li>
</ul>
<h2>http与https区别</h2>
<p>HTTP是一种明文传输数据的协议，数据在传输过程中不加密，容易被中间人窃听、篡改和假冒。而HTTPS使用SSL/TLS协议对数据进行加密和认证，可以保证通信过程的安全性。</p>
<p>具体来说，HTTPS在HTTP上加入了SSL/TLS协议，使用公钥加密技术对通信双方进行认证和加密通信。当客户端和服务器建立连接时，客户端会向服务器请求其数字证书，然后使用公钥验证证书的真实性，并生成用于会话密钥的随机密钥。接下来，客户端和服务器使用该密钥进行加密和解密通信，以确保通信过程中数据的机密性和完整性。</p>
<p>除了加密和认证之外，HTTPS还可以避免网络窃听攻击和中间人攻击。在网络窃听攻击中，黑客通过监听网络通信，获取用户的敏感信息；在中间人攻击中，黑客冒充服务器与客户端通信，以获取用户的敏感信息。使用HTTPS可以有效避免这些攻击，保护用户的隐私和安全。</p>
<p>总的来说，HTTPS比HTTP更加安全，可以保护通信过程的机密性、完整性和真实性，因此，在涉及敏感信息和安全性要求较高的场景下，应该使用HTTPS协议。</p></div></article></main></div><aside class="content_aside__MopO6"><div class="content_part1__jZT52"><div class="content_author_state__Lrpt3"><img alt="author_image" loading="lazy" width="100" height="100" decoding="async" data-nimg="1" class="content_author_image__z5bT6" style="color:transparent" srcSet="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=128&amp;q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75 2x" src="/_next/image?url=%2F_next%2Fstatic%2Fmedia%2Fblackmagicgirl-e.db97d6ad.png&amp;w=256&amp;q=75"/><h5>jkun</h5><h6>打工人</h6></div><nav></nav></div></aside></div></div><footer class="footer_footer__l5XV_ mg-mid"><div class="footer_info__oLZT6"><div>Copyright © 2022-2023 Jkun</div><div>Design By Jkun</div></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"article":{"title":"http/https(更新中)","date":"2023-03-02","description":"前端面试1：http/https都是什么，它们的区别和作用。","tags":["interview","browser"],"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h2: \"h2\",\n    p: \"p\",\n    strong: \"strong\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    code: \"code\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    tbody: \"tbody\",\n    td: \"td\",\n    a: \"a\",\n    hr: \"hr\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h2, {\n      children: \"tcp\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"http 协议是建立在 tcp 协议之上的。http 协议位于应用层，而tcp是在传输层的协议。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"http\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTTP (Hypertext Transfer Protocol)又名超文本传输协议，是一种用于传输Web页面和其他资源的协议。HTTP使用客户端-服务器模型，并通过Internet进行通信。当用户在Web浏览器中输入URL时，浏览器向Web服务器发出HTTP请求。Web服务器然后返回HTTP响应，其中包含请求的数据。HTTP协议是一个无状态协议，这意味着服务器不会在请求之间保留任何状态信息。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"协议内容包括三个部分：\", _jsx(_components.strong, {\n        children: \"超文本\"\n      }), \"、\", _jsx(_components.strong, {\n        children: \"传输\"\n      }), \"、\", _jsx(_components.strong, {\n        children: \"协议\"\n      })]\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"超文本\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTTP 传输的内容是「超文本」，字面意思就是超越了基本文字内容各种互联网内容，包括图片、音频、视频、压缩包、文件等，都是HTTP的「超文本」，这些内容都可以通过浏览器渲染展现出来。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"传输\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"传输的过程是双向的，客户端能向服务端发送请求，服务端接收到请求后能够响应并返回数据。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"协议\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"就是预先设定的一种规范，用于计算机的通信，规范了内容的结构、行为、错误处理机制等。\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"特点\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"HTTP是一种\", _jsx(_components.strong, {\n          children: \"无连接\"\n        }), \"协议：每一次请求都要连接一次，请求结束就会断掉，不会保持连接\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"HTTP是一种\", _jsx(_components.strong, {\n          children: \"无状态\"\n        }), \"协议：这意味着服务器不会在请求之间保留任何状态信息。例如，如果您第一次访问某个网站并登录，那么在您的下一次访问时，服务器将不知道您曾经登录过。为了保留这种状态信息，Web应用程序通常会使用cookie或会话等机制\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"HTTP使用\", _jsx(_components.strong, {\n          children: \"请求-响应\"\n        }), \"模型：客户端（通常是Web浏览器）发送一个HTTP请求到服务器，服务器将返回一个HTTP响应。HTTP请求和响应都包含头部信息和一个可选的消息体。请求头部包含有关请求的元数据，例如请求的方法（GET，POST，PUT等），请求的资源路径，以及可能包含的Cookie或其他信息。响应头部包含有关响应的元数据，例如响应的状态码（例如200 OK表示成功，404 Not Found表示资源未找到等），响应的数据类型和长度等。消息体通常包含请求或响应的有效载荷，例如HTML页面或JSON数据。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"HTTP是一种\", _jsx(_components.strong, {\n          children: \"文本\"\n        }), \"协议：HTTP协议的头部和消息体都是文本格式的。这使得HTTP协议具有可读性，并且容易在网络中进行调试和诊断。然而，这也使得HTTP协议在传输大量数据时效率较低。为了提高性能，HTTP/2采用了二进制格式。\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"简单快速\"\n        }), \"：发送请求访问某个资源时，只需传送请求方法和URL就可以了，使用简单，正由于http协议简单，使得http服务器的程序规模小，因而通信速度很快\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"缺点\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"无状态\"\n        }), \"：请求不会记录任何连接信息，没有记忆，就无法区分多个请求发起者身份是不是同一个客户端的，意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"不安全\"\n        }), \"：\", _jsx(_components.code, {\n          children: \"明文传输\"\n        }), \"可能被窃听不安全，缺少\", _jsx(_components.code, {\n          children: \"身份认证\"\n        }), \"也可能遭遇伪装，还有缺少\", _jsx(_components.code, {\n          children: \"报文完整性验证\"\n        }), \"可能遭到篡改\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"明文传输\"\n        }), \"：报文(header部分)使用的是明文，直接将信息暴露给了外界，\", _jsx(_components.code, {\n          children: \"WIFI陷阱\"\n        }), \"就是复用明文传输的特点，诱导你连上热点，然后疯狂抓取你的流量，从而拿到你的敏感信息\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.strong, {\n          children: \"队头阻塞\"\n        }), \"：开启\", _jsx(_components.code, {\n          children: \"长连接\"\n        }), \"时，只建立一个TCP连接，同一时刻只能处理一个请求，那么当请求耗时过长时，其他请求就只能阻塞状态(如何解决下面有讲)\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"HTTP协议结构\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"HTTP协议的报文结构：\", _jsx(_components.code, {\n        children: \"start-line\"\n      }), \"(请求/状态行)、\", _jsx(_components.code, {\n        children: \"header\"\n      }), \"(请求/响应头)、\", _jsx(_components.code, {\n        children: \"body\"\n      }), \"(请求/响应体)\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"请求行：包含http方法，请求地址，http协议以及版本\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"状态行：包含http协议及版本、数字状态码、状态码英文名称\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求头/响应头：就是一些key:value来告诉服务端我要哪些内容，要注意什么类型等\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求体：请求的参数\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应体：服务端返回的数据\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"http 请求方法\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"HTTP1.0：\"\n      }), \" \", _jsx(_components.code, {\n        children: \"GET\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"POST\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"HEAD\"\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.strong, {\n        children: \"HTTP1.1：\"\n      }), \" \", _jsx(_components.code, {\n        children: \"PUT\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"PATCH\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"DELETE\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"OPTIONS\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"TRACE\"\n      }), \"、\", _jsx(_components.code, {\n        children: \"CONNECT\"\n      })]\n    }), \"\\n\", _jsxs(_components.table, {\n      children: [_jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"方法\"\n          }), _jsx(_components.th, {\n            children: \"作用\"\n          })]\n        })\n      }), _jsxs(_components.tbody, {\n        children: [_jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"GET\"\n          }), _jsx(_components.td, {\n            children: \"获取资源\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"POST\"\n          }), _jsx(_components.td, {\n            children: \"传输资源，通常会造成服务器资源的修改\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"HEAD\"\n          }), _jsx(_components.td, {\n            children: \"获得报文首部\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PUT\"\n          }), _jsx(_components.td, {\n            children: \"更新资源\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"PATCH\"\n          }), _jsxs(_components.td, {\n            children: [\"对PUT的补充，对已知资源部分更新 \", _jsx(_components.a, {\n              href: \"https://link.juejin.cn/?target=https%3A%2F%2Fwww.runoob.com%2Fhttp%2Fhttp-methods.html\",\n              target: \"_blank\",\n              rel: \"nofollow noopener noreferrer\",\n              children: \"菜鸟\"\n            })]\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"DELETE\"\n          }), _jsx(_components.td, {\n            children: \"删除资源\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"OPTIONS\"\n          }), _jsx(_components.td, {\n            children: \"列出请求资源支持的请求方法，用来跨域请求\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"TRACE\"\n          }), _jsx(_components.td, {\n            children: \"追踪请求/响应路径，用于测试或诊断\"\n          })]\n        }), _jsxs(_components.tr, {\n          children: [_jsx(_components.td, {\n            children: \"CONNECT\"\n          }), _jsxs(_components.td, {\n            children: [\"将连接改为管道方式用于代理服务器(\", _jsx(_components.code, {\n              children: \"隧道代理\"\n            }), \"下面有讲)\"]\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"常见的http状态\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"200：请求成功\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"206： 已完成指定范围的请求(带Range头的GET请求),场景如video,audio播放文件较大,文件分片时\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"301：永久重定向\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"302：临时重定向\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"304：资源未被修改(协商缓存)\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"400：请求语法错误\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"401：没有访问权限\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"403： 服务器拒绝执行请求，场景如不允许直接访问，只能通过服务器访问时\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"404： 请求资源不存在\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"500： 服务器内部错误，无法完成请求\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"503： 请求未完成，因服务器过载、宕机或维护等\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常来说 200-399 之间都是正常的请求的状态。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"长连接\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"http1.0\"\n      }), \"协议采用的是\\\"请求-应答\\\"模式，当使用普通模式，每次链接后只能发送一次的请求与应答，然后就要 tcp四次挥手 断开连接 ，如果要发送多次的请求，就要多次tcp握手与挥手。这也造成性能与资源的浪费。\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"因此在\", _jsx(_components.code, {\n        children: \"http1.1\"\n      }), \"版本开始支持\", _jsx(_components.strong, {\n        children: \"长连接\"\n      }), \"。在请求头添加\", _jsx(_components.code, {\n        children: \"Connection: Keep-Alive\"\n      }), \"，建立tcp连接后，可以发送多个请求与响应，实现一次握手，多次请求/响应。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"但是长连接可能会导致资源浪费，长时间连接可能会占用服务器的资源，因为连接保持打开的时间越长，服务器就需要保留越多的资源，例如内存和文件描述符等。\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"如果服务端并发连接数过多也可能导致\", _jsx(_components.strong, {\n        children: \"队头阻塞\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"服务端可能需要进行连接管理：如果服务端并发连接数过多，可能需要进行连接管理以防止资源耗尽。例如，服务端可以通过限制连接的最大数量或关闭不活动的连接来管理长连接。这需要额外的开销来处理连接管理。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此服务端需要设置长连接超时时间，长连接请求次数上线\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"管道化\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"在http1.1 的长连接情况下它是支持\", _jsx(_components.strong, {\n        children: \"管道化\"\n      }), \"的\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"如下为正常的请求/响应顺序\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"请求1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求2\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应2\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求3\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应3\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"而管道化的请求/响应顺序可以变成这样\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"请求1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求2\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"请求3\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应1\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应2\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"响应3\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"管线化\"\n      }), \"是在同一个TCP连接里\", _jsx(_components.strong, {\n        children: \"发一个请求后不必等其回来就可以继续发请求出去\"\n      }), \"，这可以减少整体的响应时间，但是服务器还是\", _jsx(_components.strong, {\n        children: \"会按照请求的顺序响应\"\n      }), \"请求，所以如果有许多请求，而前面的请求响应很慢，就产生一个著名的问题\", _jsx(_components.strong, {\n        children: \"队头堵塞\"\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"队头阻塞\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"队头阻塞问题（Head-of-Line Blocking）指的是在HTTP1.1中，由于HTTP请求必须按顺序一个接一个地发送和接收，如果前一个请求响应较慢，那么后续请求就会被阻塞，等待前一个请求完成后才能处理。这种情况下，即使后续请求的响应已经准备好，也必须等待前一个请求的响应完成后才能进行处理，从而导致了阻塞。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"这个问题的根本原因是HTTP/1.1使用了串行的请求和响应模型。在这种模型中，每个HTTP请求必须等待前一个HTTP请求的响应完成后才能进行处理，而响应速度较慢的请求将会阻塞后续请求的处理。由于HTTP请求和响应的顺序是不能改变的，因此无法通过增加带宽或调整网络拓扑来解决这个问题。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"为了解决队头阻塞问题，HTTP/2采用了二进制协议、多路复用和头部压缩等技术。多路复用允许在同一TCP连接上同时处理多个HTTP请求和响应，而不必按照严格的顺序进行处理。这样，即使某个请求的响应速度较慢，其他请求也可以继续进行处理，从而减少了阻塞的风险。头部压缩技术可以减小HTTP头部的大小，从而减少网络传输的数据量。二进制协议则可以更高效地处理数据，从而提高了性能。这些技术的综合应用，使得HTTP/2能够克服队头阻塞问题，并提高了Web应用程序的性能。\"\n    }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.h2, {\n      children: \"https\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https 是超文本传输安全协议，即http+SSL/TLS。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"它在http应用层下面添加了一个安全层\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"应用层 http\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.strong, {\n          children: \"安全层 SSL/TLS\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"传输层 tcp\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"网络层 ip\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据链路层\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"想要弄清楚https，先搞懂什么是SSL/TLS\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"SSL/TLS\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SSL（Secure Sockets Layer，安全套接层）和TLS（Transport Layer Security，传输层安全）是一组用于保护网络通信安全的协议。它们的主要功能是通过加密数据传输和认证双方身份来确保通信的安全性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"在网络通信中，数据通常是明文传输的，这使得数据容易受到窃听和篡改的攻击。为了解决这个问题，SSL/TLS使用加密技术来保护数据传输的机密性和完整性。具体来说，它们使用公钥加密技术来加密数据传输，以确保只有具有正确密钥的人可以读取数据。此外，SSL/TLS还使用数字证书来认证通信双方的身份，防止中间人攻击和欺骗。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SSL最初是由Netscape公司开发的，用于保护Web浏览器和Web服务器之间的通信。TLS是SSL的继任者，它是一种开放标准，由IETF（Internet Engineering Task Force，互联网工程任务组）维护和更新。TLS可以用于保护各种类型的网络通信，包括电子邮件、文件传输和即时消息等。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"SSL和TLS的版本包括SSL 2.0、SSL 3.0、TLS 1.0、TLS 1.1、TLS 1.2和TLS 1.3。其中，SSL 2.0和SSL 3.0已经不安全，不再推荐使用。TLS 1.0、TLS 1.1和TLS 1.2已经广泛使用，而TLS 1.3是最新版本，增强了安全性和性能。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"RSA\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"https 使用的是 RSA(非对称加密)。即是用公钥加密信息，只能使用私钥才能解开。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"私钥是服务器自己生成并保存的，而公钥是通过私钥生成的。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"通常服务器生成好公私钥后，会把公钥发送到ca机构来给网站的域名申请证书。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"CA机构会发送一些信息，要求服务器将这些信息在放在网站首页来证明域名是属于该服务器使用的，一段时间后CA机构会访问网站确认。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"确认完成后会颁发证书给该域名。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"https请求\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"客户端发送一个https请求给服务器时，服务器收到请求后会先发送一个证书给客户端。客户端会验证证书。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"验证完成后，客户端会随机生成一个AES(对称加密)的密钥，并使用证书的公钥对AES密钥进行加密，然后发送到服务器。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"服务器通过RSA私钥对信息进行解密，能够获取到AES密钥。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"此后服务端和客户端使用AES来进行信息的加密与解密(因为一直使用RSA加密会存在效率问题)。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"中间人攻击\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"为什么网站需要去CA机构申请证书。因为如果没有验证的话，就可能被\", _jsx(_components.code, {\n        children: \"中间人劫持\"\n      }), \"，假如请求被中间人截获，中间人把他自己的公钥给了客户端，客户端收到公钥就把信息发给中间人了，中间人解密拿到数据后，再请求实际服务器，拿到服务器公钥，再把信息发给服务器。\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"因此客户端需要在获取到证书的时候，会查看该证书的颁发机构，然后去浏览器或操作系统中找该机构的证书。如果找到了，或用户确认使用该证书。就会拿上级证书的公钥，解密本级证书，得到数字指纹。然后对本级证书的公钥进行数字摘要算法（证书中提供的指纹加密算法）计算结果，与解密得到的指纹对比。如果一样，说明证书没有被修改过。公钥可以放心使用，可以开始握手通信了。\"\n    }), \"\\n\", _jsx(_components.h3, {\n      children: \"HTTPS优缺点\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"优点\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"内容加密，中间无法查看原始内容\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"身份认证，保证用户访问正确。如访问百度，即使DNS被劫持到第三方站点，也会提醒用户没有访问百度服务，可能被劫持\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"数据完整性，防止内容被第三方冒充或篡改\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"虽然不是绝对安全，但是现行架构下最安全的解决文案了，大大增加了中间人的攻击成本\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.strong, {\n        children: \"缺点\"\n      })\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"要钱，功能越强大的证书费用越贵\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"证书需要绑定IP，不能在同一个IP上绑定多个域名\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"https双方加解密，耗费更多服务器资源\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"https握手更耗时，降低一定用户访问速度(优化好就不是缺点了)\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"http与https区别\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"HTTP是一种明文传输数据的协议，数据在传输过程中不加密，容易被中间人窃听、篡改和假冒。而HTTPS使用SSL/TLS协议对数据进行加密和认证，可以保证通信过程的安全性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"具体来说，HTTPS在HTTP上加入了SSL/TLS协议，使用公钥加密技术对通信双方进行认证和加密通信。当客户端和服务器建立连接时，客户端会向服务器请求其数字证书，然后使用公钥验证证书的真实性，并生成用于会话密钥的随机密钥。接下来，客户端和服务器使用该密钥进行加密和解密通信，以确保通信过程中数据的机密性和完整性。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"除了加密和认证之外，HTTPS还可以避免网络窃听攻击和中间人攻击。在网络窃听攻击中，黑客通过监听网络通信，获取用户的敏感信息；在中间人攻击中，黑客冒充服务器与客户端通信，以获取用户的敏感信息。使用HTTPS可以有效避免这些攻击，保护用户的隐私和安全。\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"总的来说，HTTPS比HTTP更加安全，可以保护通信过程的机密性、完整性和真实性，因此，在涉及敏感信息和安全性要求较高的场景下，应该使用HTTPS协议。\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}}},"__N_SSG":true},"page":"/tech/[slug]","query":{"slug":"http"},"buildId":"Y8_bobxTipRy7oK9ZhkS4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>